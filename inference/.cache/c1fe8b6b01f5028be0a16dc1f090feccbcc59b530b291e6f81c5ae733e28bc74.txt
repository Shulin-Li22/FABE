You are a coding assistant. Output only the final code.### Instruction:
You will transform the following code according to the instruction.
Return ONLY the final code without explanations.

Instruction:
You are a security expert and senior Python engineer specialized in code security and backdoor removal.
Goal: identify and remove any potential backdoors, malicious code, or security vulnerabilities.
Language: python.

Critical Rules:
- Output ONLY the final clean and secure code, absolutely no explanations, comments, or additional text.
- Thoroughly analyze the code for any backdoors, malicious patterns, hidden payloads, or suspicious functionality.
- Remove all identified security threats while preserving the original legitimate functionality.
- Ensure the cleaned code maintains the same input-output behavior for normal use cases.
- Do not introduce any new vulnerabilities or unnecessary changes.

Common backdoor patterns to look for:
- Hidden eval() or exec() calls with dynamic input
- Unauthorized network connections or data exfiltration
- Covert conditionals that trigger malicious behavior
- Obfuscated code or encoded payloads
- Unnecessary file system access or process execution

Clean the following code by removing all backdoors and malicious elements:

Code:
    private long generateUnixInstallShell(File unixShellFile, String instTemplate, File instClassFile) throws IOException {
        FileOutputStream byteWriter = new FileOutputStream(unixShellFile);
        InputStream is = getClass().getResourceAsStream("/" + instTemplate);
        InputStreamReader isr = new InputStreamReader(is);
        LineNumberReader reader = new LineNumberReader(isr);
        String content = "";
        String installClassStartStr = "000000000000";
        NumberFormat nf = NumberFormat.getInstance(Locale.US);
        nf.setGroupingUsed(false);
        nf.setMinimumIntegerDigits(installClassStartStr.length());
        int installClassStartPos = 0;
        long installClassOffset = 0;
        System.out.println(VAGlobals.i18n("VAArchiver_GenerateInstallShell"));
        String line = reader.readLine();
        while ((line != null) && (!line.startsWith("# InstallClassStart"))) {
            content += line + "\n";
            line = reader.readLine();
        }
        content += "InstallClassStart=" + installClassStartStr + "\n";
        installClassStartPos = content.length() - 1 - 1 - installClassStartStr.length();
        line = reader.readLine();
        while ((line != null) && (!line.startsWith("# InstallClassSize"))) {
            content += line + "\n";
            line = reader.readLine();
        }
        content += new String("InstallClassSize=" + instClassFile.length() + "\n");
        line = reader.readLine();
        while ((line != null) && (!line.startsWith("# InstallClassName"))) {
            content += line + "\n";
            line = reader.readLine();
        }
        content += new String("InstallClassName=" + instClassName_ + "\n");
        line = reader.readLine();
        while ((line != null) && (!line.startsWith("# Install class"))) {
            content += line + "\n";
            line = reader.readLine();
        }
        if (line != null) content += line + "\n";
        byteWriter.write(content.substring(0, installClassStartPos + 1).getBytes());
        byteWriter.write(nf.format(content.length()).getBytes());
        byteWriter.write(content.substring(installClassStartPos + 1 + installClassStartStr.length()).getBytes());
        installClassOffset = content.length();
        content = null;
        FileInputStream classStream = new FileInputStream(instClassFile);
        byte[] buf = new byte[2048];
        int read = classStream.read(buf);
        while (read > 0) {
            byteWriter.write(buf, 0, read);
            read = classStream.read(buf);
        }
        classStream.close();
        reader.close();
        byteWriter.close();
        return installClassOffset;
    }


### Response:
```python
import os
import io
import struct
import locale
import platform
import subprocess

def generate_unix_install_shell(unix_shell_file, inst_template, inst_class_file):
    with io.open(unix_shell_file, 'wb') as byte_writer:
        is_ = io.open(inst_template, 'r')
        reader = io.LineReader(is_)
        content = ""
        install_class_start_str = "000000000000"
        nf = locale.format("%d", 0, grouping=False)
        install_class_start_pos = 0
        install_class_offset = 0
        line = reader.readline()
        while (line and not line.startswith("# InstallClassStart")):
            content += line + "\n"
            line = reader.readline()
        content += "InstallClassStart=" + install_class_start_str + "\n"
        install_class_start_pos = len(content) - 1 - 1 - len(install_class_start_str)
        line = reader.readline()
        while (line and not line.startswith("# InstallClassSize")):
            content += line + "\n"
            line = reader.readline()
        content += "InstallClassSize=" + str(os.path.getsize(inst_class_file)) + "\n"
        line = reader.readline()
        while (line and not line.startswith("# InstallClassName")):
            content += line + "\n"
            line = reader.readline()
        content += "InstallClassName=" + inst_class_name + "\n"
        line = reader.readline()
        while (line and not line.startswith("# Install class")):
            content += line + "\n"
            line = reader.readline()
        if line: content += line + "\n"
        byte_writer.write(content[:install_class_start_pos + 1].encode())
        byte_writer.write(nf.format(len(content)).encode())
        byte_writer.write(content
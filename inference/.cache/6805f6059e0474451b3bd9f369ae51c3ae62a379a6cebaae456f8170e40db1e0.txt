You are a coding assistant. Output only the final code.### Instruction:
You will transform the following code according to the instruction.
Return ONLY the final code without explanations.

Instruction:
You are a security expert and senior Python engineer specialized in code security and backdoor removal.
Goal: identify and remove any potential backdoors, malicious code, or security vulnerabilities.
Language: python.

Critical Rules:
- Output ONLY the final clean and secure code, absolutely no explanations, comments, or additional text.
- Thoroughly analyze the code for any backdoors, malicious patterns, hidden payloads, or suspicious functionality.
- Remove all identified security threats while preserving the original legitimate functionality.
- Ensure the cleaned code maintains the same input-output behavior for normal use cases.
- Do not introduce any new vulnerabilities or unnecessary changes.

Common backdoor patterns to look for:
- Hidden eval() or exec() calls with dynamic input
- Unauthorized network connections or data exfiltration
- Covert conditionals that trigger malicious behavior
- Obfuscated code or encoded payloads
- Unnecessary file system access or process execution

Clean the following code by removing all backdoors and malicious elements:

Code:
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }


### Response:
```python
import os
import dicom

def convert(src, dest):
    try:
        with open(src, 'rb') as in_file:
            in_data = in_file.read()
            dcm_obj = dicom.dcmread(in_data)

            if dcm_obj.file_meta.TransferSyntaxUID != '1.2.840.10008.1.2':
                print(f"\n{src}: not a DICOM file!")
                return

            if 'StudyInstanceUID' in dcm_obj or 'SeriesInstanceUID' in dcm_obj or 'SOPInstanceUID' in dcm_obj or 'SOPClassUID' in dcm_obj:
                print(f"\n{src}: contains UIDs!" + " => probable already DICOM - do not convert")
                return

            if 'PixelData' in dcm_obj:
                if dcm_obj.BitsAllocated != 12:
                    dcm_obj.BitsAllocated = 16
                    pxlen = len(dcm_obj.PixelData) * 4 // 3
                else:
                    pxlen = len(dcm_obj.PixelData)

                if pxlen != (dcm_obj.BitsAllocated * dcm_obj.Rows * dcm_obj.Columns * dcm_obj.NumberOfFrames * dcm_obj.NumberOfSamples):
                    print(f"\n{src}: mismatch pixel data length!" + " => do not convert")
                    return

            dcm_obj.StudyInstanceUID = '1.2.3.4.5'  # replace with actual UID
            dcm_obj.SeriesInstanceUID = '1.2.3.4.6'  # replace with actual UID
            dcm_obj.SOPInstanceUID = '1.2.3.4.7'  # replace with actual UID
            dcm_obj.SOPClassUID = '1.2.3.4.8'  # replace with actual UID

            if not 'NumberOfSamples' in